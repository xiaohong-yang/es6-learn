<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>es6-数组新方法</title>
</head>
<body>

</body>
<script type="application/javascript">
    // 1.arr.push() 从后面添加元素，返回值为添加完后的数组的长度
    let arr1 = [1,2,3,4,5]
    console.log(arr1.push(5))   // 6
    console.log(arr1) // [1,2,3,4,5,5]
    console.log('************************************************')
    // 2.arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素
    let arr2 = [1,2,3,4,5]
    console.log(arr2.pop())     // 5
    console.log(arr2)  //[1,2,3,4]
    console.log('************************************************')
    // 3.arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素
    let arr3 = [1,2,3,4,5]
    console.log(arr3.shift())  // 1
    console.log(arr3)   // [2,3,4,5]
    console.log('************************************************')
    // 4.arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度
    let arr4 = [1,2,3,4,5]
    console.log(arr4.shift())  // 1
    console.log(arr4)   // [2,3,4,5]
    console.log('************************************************')
    // 5.arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素(参数： i 索引值  n 个数)
    let arr5 = [1,2,3,4,5]
    console.log(arr5.splice(2,2))     //[3,4]
    console.log(arr5)    // [1,2,5]
    console.log('************************************************')
    // 6.arr.concat() 连接两个数组 返回值为连接后的新数组
    let arr6 = [1,2,3,4,5]
    console.log(arr6.concat([1,2]))  // [1,2,3,4,5,1,2]
    console.log(arr6)   // [1,2,3,4,5]
    console.log('************************************************')
    // 7.str.split() 将字符串转化为数组
    let str7 = '123456'
    console.log(str7.split('')) // ["1", "2", "3", "4", "5", "6"]
    console.log('************************************************')
    // 8.arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子。
    let arr8 = [2,10,6,1,4,22,3]
    console.log(arr8.sort())   // [1, 10, 2, 22, 3, 4, 6]
    let newArr1 = arr8.sort((a, b) =>a - b)
    console.log(newArr1)   // [1, 2, 3, 4, 6, 10, 22]
    let newArr2 = arr8.sort((a, b) =>b - a)
    console.log(newArr2)  // [22, 10, 6, 4, 3, 2, 1]
    console.log('************************************************')
    // 9.arr.reverse() 将数组反转,返回值是反转后的数组
    let arr9 = [1,2,3,4,5]
    console.log(arr9.reverse())    // [5,4,3,2,1]
    console.log(arr9)    // [5,4,3,2,1]
    console.log('************************************************')
    // 10.arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组
    let arr10 = [1,2,3,4,5]
    console.log(arr10.slice(1,3))   // [2,3]
    console.log(arr10)    //  [1,2,3,4,5]
    console.log('************************************************')
    // 11.arr.forEach(callback) 遍历数组,无return  即使有return，也不会返回任何值，并且会影响原来的数组 callback的参数： value --当前索引的值 index --索引 array --原数组
    console.log('************************************************')
    let arr11 = [1,2,3,4,5]
    arr11.forEach( (value,index,array)=>{
        console.log(`value:${value}    index:${index}     array:${array}`)
    })
    //  value:1    index:0     array:1,2,3,4,5
    //  value:2    index:1     array:1,2,3,4,5
    //  value:3    index:2     array:1,2,3,4,5
    //  value:4    index:3     array:1,2,3,4,5
    //  value:5    index:4     array:1,2,3,4,5

    arr11.forEach( (value,index,array)=>{
        value = value * 2
        console.log(`value:${value}    index:${index}     array:${array}`)
    })
    console.log(arr11)
    // value:2    index:0     array:1,2,3,4,5
    // value:4    index:1     array:1,2,3,4,5
    // value:6    index:2     array:1,2,3,4,5
    // value:8    index:3     array:1,2,3,4,5
    // value:10   index:4     array:1,2,3,4,5
    // [1, 2, 3, 4, 5]

    let newArr3 = [1,2,3,4];
    let res3 = newArr3.forEach((item,index,arr)=>{
        arr[index] = item * 2;
        return arr
    })
    console.log(newArr3); // [2,4,6,8]
    console.log(res3); // undefined
    console.log('************************************************')
    // 12.arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组。 callback的参数： value --当前索引的值 index --索引 array --原数组
    let arr12 = [1,2,3,4,5]
    arr12.map( (value,index,array)=>{
        value = value * 2
        console.log(`value:${value}    index:${index}     array:${array}`)
    })
    console.log(arr12)

    let newArr4 = [1,2,3,4];
    let res4 = arr1.map((item,index,arr)=>{
        item = item * 3;
        return item;
    })
    console.log(newArr4); // [1,2,3,4]
    console.log(res4); // [3,6,9,12]
    /*
        arr.forEach()和arr.map()的区别
            1. arr.forEach()是和for循环一样，是代替for。arr.map()是修改数组其中的数据，并返回新的数据。
            2. arr.forEach() 没有return  arr.map() 有return
    */
    console.log('************************************************')
    // 13.arr.filter(callback) 过滤数组，返回一个满足要求的数组 callback的参数： value --当前索引的值 index --索引
    let arr13 = [1,2,3,4,5]
    let newArr5 = arr13.filter( (value, index) => value<3)
    console.log(newArr5)    // [1, 2]
    console.log('************************************************')
    // 14.arr.every(callback) 依据判断条件，数组的元素是否全满足，若满足则返回ture callback的参数： value --当前索引的值 index --索引
    let arr14 = [1,2,3,4,5]
    let newArr6 = arr14.every( (value, index) =>value<3)
    console.log(newArr6) // false
    let newArr7 = arr14.every( (value, index) =>value<6)
    console.log(newArr7)  // true
    console.log('************************************************')
    // 15.arr.some() 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture callback的参数： value --当前索引的值 index --索引
    let arr15 = [1,2,3,4,5]
    let newArr8 = arr15.some( (value, index) =>value<3)
    console.log(newArr8) // true
    let newArr9 = arr15.some( (value, index) =>value>6)
    console.log(newArr9) // false
    console.log('************************************************')
    // 16.arr.indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1
    let arr16 = [1,2,3,4,5,2]
    let newArr10 = arr16.indexOf(2)
    console.log(newArr10)  // 1
    let newArr11 = arr16.indexOf(9)
    console.log(newArr11)  // -1
    console.log('************************************************')
    // 17.arr.lastIndexOf()   和arr.indexOf()的功能一样，不同的是从后往前查找
    let arr17 = [1,2,3,4,5,2]
    let newArr12 = arr17.lastIndexOf(2)
    console.log(newArr12)  // 5
    let newArr13 = arr17.lastIndexOf(9)
    console.log(newArr13)  // -1
    console.log('************************************************')
    // 18.Array.from() 将伪数组变成数组，就是只要有length的就可以转成数组。 ---es6
    let str18 = '12345'
    console.log(Array.from(str18))    // ["1", "2", "3", "4", "5"]
    let obj18 = {0:'a',1:'b',length:2}
    console.log(Array.from(obj18))   // ["a", "b"]
    console.log('************************************************')
    // 19.Array.of() 将一组值转换成数组，类似于声明数组    ---es6
    let str19 = '11'
    console.log(Array.of(str19))   // ['11']
    // 等价于 console.log(new Array('11'))  // ['11]
    // 但是new Array()有缺点，就是参数问题引起的重载
    // console.log(new Array(2))   //[empty × 2]  是个空数组
    // console.log(Array.of(2))    // [2]
    console.log('************************************************')
    // 20.arr.copyWithin() 在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组
    // 参数: target --必选 索引从该位置开始替换数组项
    //      start --可选 索引从该位置开始读取数组项，默认为0.如果为负值，则从右往左读。
    // 　　　end --可选 索引到该位置停止读取的数组项，默认是Array.length,如果是负值，表示倒数
    let arr20 = [1,2,3,4,5,6,7]
    let newArr14 = arr20.copyWithin(1,0)
    console.log(newArr14)   // [1, 1, 2, 3, 4, 5, 6]
    arr20 = [1,2,3,4,5,6,7]
    let newArr15 = arr20.copyWithin(1,2)
    console.log(newArr15)   // [1, 3, 4, 5, 6, 7, 7]
    arr20 = [1,2,3,4,5,6,7]
    let newArr16 = arr20.copyWithin(1,2,4)
    console.log(newArr16)   // [1, 3, 4, 4, 5, 6, 7]
    console.log('************************************************')
    // 21.arr.find(callback) 找到第一个符合条件的数组成员
    let arr21 = [1,2,3,4,5,2,4]
    let newArr17 = arr21.find((value, index, array) =>value > 2)
    console.log(newArr17)   // 3
    console.log('************************************************')
    // 22.arr.findIndex(callback) 找到第一个符合条件的数组成员的索引值
    let arr22 = [1,2,3,4,5]
    let newArr18 = arr22.findIndex((value, index, array) => value > 3)
    console.log(newArr18)  // 3
    console.log('************************************************')
    // 23.arr.fill(target, start, end) 使用给定的值，填充一个数组,ps:填充完后会改变原数组 参数： target -- 待填充的元素 start -- 开始填充的位置-索引 end -- 终止填充的位置-索引（不包括该位置)
    let arr23 = [1,2,3,4,5]
    let newArr19 = arr23.fill(5)
    console.log(newArr19)  // [5, 5, 5, 5, 5]
    console.log(arr23)   // [5, 5, 5, 5, 5]
    let newArr20 = arr23.fill(5,2)
    console.log(newArr20)
    let newArr21 = arr23.fill(5,1,3)
    console.log(newArr21)
    console.log('************************************************')
    // 24.arr.includes() 判断数中是否包含给定的值
    let arr24 = [1,2,3,4,5]
    let newArr22 = arr24.includes(2)
    console.log(newArr22)   // ture
    let newArr23 = arr24.includes(9)
    console.log(newArr23)    // false
    let newArr24 = [1,2,3,NaN].includes(NaN)
    console.log(newArr24)  // true
    /*
        includes()与indexOf()的区别：
            1 indexOf()返回的是数值，而includes()返回的是布尔值
            2 indexOf() 不能判断NaN，返回为-1 ，includes()则可以判断
     */
    console.log('************************************************')
    // 25.arr.reduce(callback, initialValue) 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值
    // 参数： callback: previousValue 必选 --上一次调用回调返回的值，或者是提供的初始值（initialValue）
    //       currentValue 必选 --数组中当前被处理的数组项
    //       index 可选 --当前数组项在数组中的索引值
    //       array 可选 --原数组
    //       initialValue: 可选 --初始值
    // 实行方法：回调函数第一次执行时，preValue 和 curValue 可以是一个值，如果 initialValue 在调用 reduce() 时被提供，那么第一个 preValue 等于 initialValue ，并且curValue 等于数组中的第一个值；如果initialValue 未被提供，那么preValue 等于数组中的第一个值.
    console.log('************************************************')
    let arr25 = [0,1,2,3,4]
    let newArr25 = arr25.reduce((preValue, curValue) =>
        preValue + curValue
    )
    console.log(newArr25)    // 10
    let newArr26 = arr25.reduce((preValue,curValue)=>preValue + curValue,5)
    console.log(newArr26)    // 15
    // reduce的高级用法
        // （1）计算数组中每个元素出现的次数
        let names = ['peter', 'tom', 'mary', 'bob', 'tom','peter'];
        let nameNum = names.reduce((pre,cur)=>{
            if(cur in pre){
                pre[cur]++
            }else{
                pre[cur] = 1
            }
            return pre
        },{})
        console.log(nameNum); //{ peter: 2, tom: 2, mary: 1, bob: 1 }
        // （2）数组去重
        let reduceArr1 = [1,2,3,4,4,1]
        let reduceNewArr1 = reduceArr1.reduce((pre,cur)=>{
            if(!pre.includes(cur)){
                return pre.concat(cur)
            }else{
                return pre
            }
        },[])
        console.log(reduceNewArr1);// [1, 2, 3, 4]
        // （3）将多维数组转化为一维
        let reduceArr2 = [[0, 1], [2, 3], [4,[5,6,7]]]
        const reduceNewArr2 = function(reduceArr2){
            return reduceArr2.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?reduceNewArr2(cur):cur),[])
        }
        console.log(reduceNewArr2(reduceArr2)); //[0, 1, 2, 3, 4, 5, 6, 7]
    console.log('************************************************')
    // 17.arr.reduceRight(callback, initialValue) 与arr.reduce()功能一样，不同的是，reduceRight()从数组的末尾向前将数组中的数组项做累加。
    console.log('************************************************')
</script>
</html>
